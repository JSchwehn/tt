#!/usr/bin/env python3
# This is a script intended to track your project activities.
# It is really simple and I got the idea when using todolist on the command
# line. tymetracker (tt) is written entirely in Python 3 and stores the
# records in a json data structure in the user's home directory.
#
datafile = "~/.tymetracker.json"
dateformat = "%Y-%m-%dT%H:%M:%S"


#############################################################################
### Here be dragons!
#############################################################################

# Sanity check: only proceed if we are in a python3 environment
import sys
try:
    assert sys.version_info >= (3,0)
except:
    print("Python 3 is required to run tymetracker/tt.")
    sys.exit(1)

# Import stuff we need
import datetime
import json
import os

# Set variables we need
f = os.path.abspath(os.path.expanduser(datafile))



#############################################################################
### Helper functions
#############################################################################

class bcolors:
    """Define some colors that can be used in the terminal.
    """
    PURPLE = '\033[95m'
    BLUE = '\033[94m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    RED = '\033[91m'
    END = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'


def _get_project_name(data, project_id):
    """Get a project's name.
    """
    try:
        return data["projects"][project_id]["name"]
    except:
        return None


def _timestamp():
    """Return a timestamp.
    This timestamp is crucial since it is used in the JSON file to store
    the beginning and end of the the time periods.
    We use the ISO format to ensure that humans can read (and modify) the
    values manually if needed.
    """
    return datetime.datetime.now().strftime(dateformat)


def _time_diff(started, stopped):
    """calculates the difference between to datetimes.
    Returns a 3-tuple containing
        seconds as float (e.g., 23132.0 seconds)
        hour_frac as float (e.g., 0.3455353 hours)
        hhmm as string (e.g., 01:23)
    You can display what the user wants to see.
    """
    a = datetime.datetime.strptime(started, dateformat)
    b = datetime.datetime.strptime(stopped, dateformat)
    c = b - a
    seconds = c.total_seconds()
    hour_frac = seconds / 3600
    hhmm = "{h:02}:{m:02}".format(h=c.seconds//3600, m=(c.seconds//60)%60)

    # return tuple
    return (seconds, hour_frac, hhmm)


def _to_day_and_time(isodateformat):
    """Return the day and the time from an ISO-formatted date.
    Given a timestamp, the day and the time will be returned as a 2-tuple with
    the day in format YYYY-mm-dd as first element and the time in format HH:MM
    as the second element of the tuple.
    """
    day = datetime.datetime.strptime(isodateformat, dateformat).strftime('%Y-%m-%d')
    time = datetime.datetime.strptime(isodateformat, dateformat).strftime('%H:%M')
    return (day, time)



#############################################################################
### Data file functions
#############################################################################

def load():
    """Load the JSON datafile and return a dict with all the values.
    """
    try:
        fp = open(f, "r")
        data = json.load(fp)
        fp.close()
    except FileNotFoundError as e:
        print("Could not load data file. Please run", bcolors.YELLOW, "init", bcolors.END, "first.")
        sys.exit(3)
    except Exception as e:
        print(e)
        sys.exit(4)

    if data is None:
        print("Read corrupt data from", f)
        sys.exit(5)

    return data


def save(data):
    """Write the data dict object to disk in JSON format.
    """
    if data is not None:
        try:
            fp = open(f, "w")
            json.dump(data, fp, indent=2)
            fp.flush()
            fp.close()
        except Exception as e:
            print(e)
            sys.exit(7)
    else:
        print("No data to write")



#############################################################################
### Generic functions
#############################################################################

def init():
    """Initialize a new datafile if it does not exist.
    Cannot overwrite existing datafile, needs to be manually
    deleted beforehand.
    """
    if os.path.isfile(f):
        print("Data file {} already exists".format(f))
        sys.exit(2)
    else:
        print("Initializing new data file {}".format(f))

        # Initialize new data dict
        data = {
                "meta": {
                    "last_id": 0,
                    "file_version": 1,
                    },
                "tracking": {
                    "active": False,
                    "project": None,
                    "started": None,
                    },
                "projects": {
                    # id:    {
                        # "name": Projektname,
                        # "history": [] # tuples (start, stop, mins)
                    # }
                    },
                }

        # ... and write it to data file
        save(data)


def status():
    """Display some information about the current state. If the tracker
    is active this function displays a brief summary of the recent
    work period.
    """
    data = load()
    if not data["tracking"]["active"]:
        print("No active time tracking")
    else:
        since = data["tracking"]["started"]
        project_id = data["tracking"]["project"]
        project_name = data["projects"][project_id]["name"]
        _, hf, hhmm = _time_diff(since, _timestamp())
        print("Tracking time in project {name}: {hhmm} ({hf:0.2f} hours)".format(name=project_name, hf=hf, hhmm=hhmm))


def usage():
    """Print the list of commands that are supported. This function is
    called if the users calls tt with no or too few arguments.
    """
    group = {
            "Generic commands": {
                "init": "Initialize new data file",
                "status": "Display status information",
                },
            "Projects": {
                #"DESC": "Projects are needed for time tracking",
                "a project name": "Add new project with name \"project name\"",
                "d 23": "Delete project with id 23",
                "l": "List projects and their ids",
                },
            "Tracking": {
                #"DESC": "Time tracking is about time tracking",
                "start 23": "Starts time tracking for project id 23",
                "stop": "Stops active time tracking",
                "s": "Show tracked times for all projects",
                "s 23": "Show tracked times for project 23",
                }
            }

    # Display the commands/dicts
    for group, commands in sorted(group.items()):
        print(bcolors.PURPLE, "\n{group}".format(group=group), bcolors.END)

        # print the DESC if needed
        if "DESC" in commands:
            print("{desc}".format(desc=commands["DESC"]))

        # print all commands (and not DESC)
        for command, description in sorted(commands.items()):
            if command is not "DESC":
                print(bcolors.YELLOW, "    {cmd:20s}".format(cmd=command), bcolors.END, description)



#############################################################################
### Projects
#############################################################################

def list_projects():
    """Print all existing projects.
    """
    data = load()
    p = data.get("projects", {})

    if len(p) == 0:
        print("No projects found.")
    else:
        for project_id, project_data in sorted(p.items()):
            #print("    {i:>3}   {n}".format(i=project_id, n=project_data["name"]))
            print("    {cb}{i:>3}{ce}   {n}".format(cb=bcolors.YELLOW, i=project_id, ce=bcolors.END, n=project_data["name"]))


def add_project():
    """Add a project.
    You need to specify a project name. The project name can contain spaces.
    When created, this function prints the id of the created project.
    """
    if len(sys.argv) < 3:
        print("You must specify a project name")
        sys.exit(10)

    name = " ".join(sys.argv[2:]).strip()

    data = load()

    project = {}
    project_id = int(data["meta"].get("last_id", 0)) + 1
    project["name"] = name
    project["history"] = []

    projects = data.get("projects", {})
    projects[project_id] = project

    data["meta"]["last_id"] = project_id
    data["projects"] = projects

    save(data)

    print("Created project \"{name}\" with id {i}".format(name=name, i=project_id))


def del_project():
    """Delete a project.
    You need to specify a project id.
    """
    if len(sys.argv) < 3:
        print("You must specify a project id")
        sys.exit(11)

    project_id = sys.argv[2]

    data = load()
    if project_id not in data.get("projects", {}):
        print("Project {pid} not found".format(pid=project_id))
        sys.exit(12)
    else:
        del data["projects"][project_id]
        save(data)
        print("Project {name} deleted".format(name=_get_project_name(data, project_id)))



#############################################################################
### Time tracking
#############################################################################

def start_tracking():
    """Starts a tracker for a given project.
    You must specify a project id when starting a tracker. The recorded
    time will be stored in the particular project's context.
    If a tracker is alreay active, an error will be displayed.
    """
    if len(sys.argv) < 3:
        print("You must specify a project id")
        sys.exit(20)

    project_id = sys.argv[2]

    data = load()
    if data["tracking"]["active"]:
        print("Tracker already started")
        sys.exit(21)

    data["tracking"]["active"] = True
    data["tracking"]["project"] = project_id
    data["tracking"]["started"] = _timestamp()

    save(data)
    print("Tracker started for project {name}".format(name=_get_project_name(data, project_id)))


def stop_tracking():
    """Stop a running tracker.
    No need to specify a project id (will be ignored). If no active tracker
    is found, an error is printed to the console.
    """
    data = load()
    if not data["tracking"]["active"]:
        print("Tracker not active")
        sys.exit(22)

    project_id = data["tracking"]["project"]
    started = data["tracking"]["started"]
    stopped = _timestamp()
    diff, hf, hhmm = _time_diff(started, stopped)

    # add tuple to history
    history = data["projects"][project_id]["history"]
    history.append( (started, stopped) )
    data["projects"][project_id]["history"] = history

    # reset tracking settings
    data["tracking"]["active"] = False
    data["tracking"]["project"] = None
    data["tracking"]["started"] = None

    save(data)
    print("Tracker stopped for project {name} after {duration} ({hf:1.2f} hours)".format(name=_get_project_name(data, project_id), duration=hhmm, hf=hf))


def show():
    """Show the recorded times for a particular project.
    You must specify a project id. As a result, a list of all recorded times
    will be printed to the console in the following format:
        Day           Started  Stopped  Time recorded
    ------------------------------------------------------------------------------
        2017-07-31    23:36    23:48    00:11  (0.20 hours)
    """
    data = load()
    project_ids = list() # list of project ids to display
    first = True

    if len(sys.argv) < 3:
        # no project ID given, get list of all available project IDs
        project_ids = list(data["projects"].keys())
    elif len(sys.argv) == 3:
        # project ID given, use it
        project_ids = sys.argv[2].split()
    else:
        # too many arguments, throw an error
        print("You must specify a project id")
        sys.exit(20)

    for project_id in project_ids:
        if first:
            first = False
        else:
            print()

        try:
            project_name = data["projects"][project_id]["name"]
            history = data["projects"][project_id]["history"]
        except KeyError as e:
            # Key (project_id) not found
            # continue with next loop run
            continue
   
        # Print the project's name
        print(bcolors.PURPLE, project_name, bcolors.END)
    
        # print the history
        if len(history) == 0:
            # If no history items are found, continue with next loop run
            print(bcolors.YELLOW, "   No entries", bcolors.END)
            continue
    
        old_day = ""
        
        for item in sorted(history):
            started, stopped = item
            secs, hf, hhmm = _time_diff(started, stopped)
            day, time_started = _to_day_and_time(started)
            _, time_stopped = _to_day_and_time(stopped)
            str_day = "{cb}{day:14}{ce}".format(cb=bcolors.YELLOW, day=day, ce=bcolors.END)
            if day == old_day:
                str_day = " "*14
            
            print("    {sd}{started:5} - {stopped:11}{hhmm:7}({hf:1.2f} hours)".format(sd=str_day, started=time_started, stopped=time_stopped, hhmm=hhmm, hf=hf))
            old_day = day
    


#############################################################################
### Entry point
#############################################################################

"""Main function/entry point when starting the program.
Parses the arguments and calls the appropriate functions.
"""
if len(sys.argv) <= 1:
    usage()
elif sys.argv[1].lower() == "init":
    init()
elif sys.argv[1].lower() == "status":
    status()
elif sys.argv[1].lower() == "l":
    list_projects()
elif sys.argv[1].lower() == "a":
    add_project()
elif sys.argv[1].lower() == "d":
    del_project()
elif sys.argv[1].lower() == "start":
    start_tracking()
elif sys.argv[1].lower() == "stop":
    stop_tracking()
elif sys.argv[1].lower() == "s":
    show()
else:
    usage()

# eof. thank you.
